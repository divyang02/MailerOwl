<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>apps.email_scheduler.email_sender.abstract_email_sender API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>apps.email_scheduler.email_sender.abstract_email_sender</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractEmailSender(object):

    @classmethod
    def parse_response_for_email_scheduler_logs_creation_and_email_scheduler_updation(
            cls, response: dict, retry_count: int, email_scheduler_object):
        &#34;&#34;&#34;
        This method will parse the response and return a tuple, with first element as &#34;Success&#34;/&#34;Error&#34;
        and second element will be a list of dict. In case of success, second element will contain list of
        dict for creating logs and in case of error the second element will contain list of dict of errors with
        each dict containing a key &#34;StatusCode&#34;
        Arguments:
            response {dict} -- Response from the email service
            retry_count {int} -- Retry count of the email scheduler
            email_scheduler_object {object} -- Email scheduler object
        Returns:
            Error -- NotImplementedError
        &#34;&#34;&#34;
        raise NotImplementedError

    @classmethod
    def email_service_used(cls):
        &#34;&#34;&#34;
        This method should be overrided to return a string of which email sending service is being used
        Arguments:
            None
        Returns:
            Error -- NotImplementedError
        &#34;&#34;&#34;
        raise NotImplementedError

    @classmethod
    def send_email_with_service(cls, email_scheduler_object):
        &#34;&#34;&#34;
        This method is overrided to send an email using the specific service. It takes object of
        EmailScheduler as an argument. It should return JSON containing response given by service
        Arguments:
            email_scheduler_object {object} -- Email scheduler object
        Returns:
            Error -- NotImplementedError
        &#34;&#34;&#34;
        raise NotImplementedError

    @classmethod
    def fetch_email_status_by_message_id(cls, message_id: str):
        &#34;&#34;&#34;
        This method should be overrided to check the status of a message using message id. It should
        return a dict which is returned by the service. We need to make sure that dict has a key named
        EventType which clearly specifies the event like &#34;sent&#34;, &#34;opened&#34;, &#34;hardbounce&#34; etc.
        Arguments:
            message_id {str} -- Message id of the email
        Returns:
            Error -- NotImplementedError
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="apps.email_scheduler.email_sender.abstract_email_sender.AbstractEmailSender"><code class="flex name class">
<span>class <span class="ident">AbstractEmailSender</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractEmailSender(object):

    @classmethod
    def parse_response_for_email_scheduler_logs_creation_and_email_scheduler_updation(
            cls, response: dict, retry_count: int, email_scheduler_object):
        &#34;&#34;&#34;
        This method will parse the response and return a tuple, with first element as &#34;Success&#34;/&#34;Error&#34;
        and second element will be a list of dict. In case of success, second element will contain list of
        dict for creating logs and in case of error the second element will contain list of dict of errors with
        each dict containing a key &#34;StatusCode&#34;
        Arguments:
            response {dict} -- Response from the email service
            retry_count {int} -- Retry count of the email scheduler
            email_scheduler_object {object} -- Email scheduler object
        Returns:
            Error -- NotImplementedError
        &#34;&#34;&#34;
        raise NotImplementedError

    @classmethod
    def email_service_used(cls):
        &#34;&#34;&#34;
        This method should be overrided to return a string of which email sending service is being used
        Arguments:
            None
        Returns:
            Error -- NotImplementedError
        &#34;&#34;&#34;
        raise NotImplementedError

    @classmethod
    def send_email_with_service(cls, email_scheduler_object):
        &#34;&#34;&#34;
        This method is overrided to send an email using the specific service. It takes object of
        EmailScheduler as an argument. It should return JSON containing response given by service
        Arguments:
            email_scheduler_object {object} -- Email scheduler object
        Returns:
            Error -- NotImplementedError
        &#34;&#34;&#34;
        raise NotImplementedError

    @classmethod
    def fetch_email_status_by_message_id(cls, message_id: str):
        &#34;&#34;&#34;
        This method should be overrided to check the status of a message using message id. It should
        return a dict which is returned by the service. We need to make sure that dict has a key named
        EventType which clearly specifies the event like &#34;sent&#34;, &#34;opened&#34;, &#34;hardbounce&#34; etc.
        Arguments:
            message_id {str} -- Message id of the email
        Returns:
            Error -- NotImplementedError
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="apps.email_scheduler.email_sender.mailjet_email_sender.MailjetEmailWrapper" href="mailjet_email_sender.html#apps.email_scheduler.email_sender.mailjet_email_sender.MailjetEmailWrapper">MailjetEmailWrapper</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="apps.email_scheduler.email_sender.abstract_email_sender.AbstractEmailSender.email_service_used"><code class="name flex">
<span>def <span class="ident">email_service_used</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>This method should be overrided to return a string of which email sending service is being used</p>
<h2 id="arguments">Arguments</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>Error &ndash; NotImplementedError</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def email_service_used(cls):
    &#34;&#34;&#34;
    This method should be overrided to return a string of which email sending service is being used
    Arguments:
        None
    Returns:
        Error -- NotImplementedError
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.email_sender.abstract_email_sender.AbstractEmailSender.fetch_email_status_by_message_id"><code class="name flex">
<span>def <span class="ident">fetch_email_status_by_message_id</span></span>(<span>message_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This method should be overrided to check the status of a message using message id. It should
return a dict which is returned by the service. We need to make sure that dict has a key named
EventType which clearly specifies the event like "sent", "opened", "hardbounce" etc.</p>
<h2 id="arguments">Arguments</h2>
<p>message_id {str} &ndash; Message id of the email</p>
<h2 id="returns">Returns</h2>
<p>Error &ndash; NotImplementedError</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fetch_email_status_by_message_id(cls, message_id: str):
    &#34;&#34;&#34;
    This method should be overrided to check the status of a message using message id. It should
    return a dict which is returned by the service. We need to make sure that dict has a key named
    EventType which clearly specifies the event like &#34;sent&#34;, &#34;opened&#34;, &#34;hardbounce&#34; etc.
    Arguments:
        message_id {str} -- Message id of the email
    Returns:
        Error -- NotImplementedError
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.email_sender.abstract_email_sender.AbstractEmailSender.parse_response_for_email_scheduler_logs_creation_and_email_scheduler_updation"><code class="name flex">
<span>def <span class="ident">parse_response_for_email_scheduler_logs_creation_and_email_scheduler_updation</span></span>(<span>response: dict, retry_count: int, email_scheduler_object)</span>
</code></dt>
<dd>
<div class="desc"><p>This method will parse the response and return a tuple, with first element as "Success"/"Error"
and second element will be a list of dict. In case of success, second element will contain list of
dict for creating logs and in case of error the second element will contain list of dict of errors with
each dict containing a key "StatusCode"</p>
<h2 id="arguments">Arguments</h2>
<p>response {dict} &ndash; Response from the email service
retry_count {int} &ndash; Retry count of the email scheduler
email_scheduler_object {object} &ndash; Email scheduler object</p>
<h2 id="returns">Returns</h2>
<p>Error &ndash; NotImplementedError</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse_response_for_email_scheduler_logs_creation_and_email_scheduler_updation(
        cls, response: dict, retry_count: int, email_scheduler_object):
    &#34;&#34;&#34;
    This method will parse the response and return a tuple, with first element as &#34;Success&#34;/&#34;Error&#34;
    and second element will be a list of dict. In case of success, second element will contain list of
    dict for creating logs and in case of error the second element will contain list of dict of errors with
    each dict containing a key &#34;StatusCode&#34;
    Arguments:
        response {dict} -- Response from the email service
        retry_count {int} -- Retry count of the email scheduler
        email_scheduler_object {object} -- Email scheduler object
    Returns:
        Error -- NotImplementedError
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.email_sender.abstract_email_sender.AbstractEmailSender.send_email_with_service"><code class="name flex">
<span>def <span class="ident">send_email_with_service</span></span>(<span>email_scheduler_object)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is overrided to send an email using the specific service. It takes object of
EmailScheduler as an argument. It should return JSON containing response given by service</p>
<h2 id="arguments">Arguments</h2>
<p>email_scheduler_object {object} &ndash; Email scheduler object</p>
<h2 id="returns">Returns</h2>
<p>Error &ndash; NotImplementedError</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def send_email_with_service(cls, email_scheduler_object):
    &#34;&#34;&#34;
    This method is overrided to send an email using the specific service. It takes object of
    EmailScheduler as an argument. It should return JSON containing response given by service
    Arguments:
        email_scheduler_object {object} -- Email scheduler object
    Returns:
        Error -- NotImplementedError
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="apps.email_scheduler.email_sender" href="index.html">apps.email_scheduler.email_sender</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="apps.email_scheduler.email_sender.abstract_email_sender.AbstractEmailSender" href="#apps.email_scheduler.email_sender.abstract_email_sender.AbstractEmailSender">AbstractEmailSender</a></code></h4>
<ul class="">
<li><code><a title="apps.email_scheduler.email_sender.abstract_email_sender.AbstractEmailSender.email_service_used" href="#apps.email_scheduler.email_sender.abstract_email_sender.AbstractEmailSender.email_service_used">email_service_used</a></code></li>
<li><code><a title="apps.email_scheduler.email_sender.abstract_email_sender.AbstractEmailSender.fetch_email_status_by_message_id" href="#apps.email_scheduler.email_sender.abstract_email_sender.AbstractEmailSender.fetch_email_status_by_message_id">fetch_email_status_by_message_id</a></code></li>
<li><code><a title="apps.email_scheduler.email_sender.abstract_email_sender.AbstractEmailSender.parse_response_for_email_scheduler_logs_creation_and_email_scheduler_updation" href="#apps.email_scheduler.email_sender.abstract_email_sender.AbstractEmailSender.parse_response_for_email_scheduler_logs_creation_and_email_scheduler_updation">parse_response_for_email_scheduler_logs_creation_and_email_scheduler_updation</a></code></li>
<li><code><a title="apps.email_scheduler.email_sender.abstract_email_sender.AbstractEmailSender.send_email_with_service" href="#apps.email_scheduler.email_sender.abstract_email_sender.AbstractEmailSender.send_email_with_service">send_email_with_service</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>