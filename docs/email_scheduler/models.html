<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>apps.email_scheduler.models API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>apps.email_scheduler.models</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from django.db import models
from django.contrib.postgres.fields import ArrayField
from .tasks import send_email
from .constants import *
from django.utils import timezone
from django.db.models import F, Q

# Create your models here.


class EmailScheduler(models.Model):
    &#34;&#34;&#34;
    This class will define the EmailScheduler model
    &#34;&#34;&#34;
    email_to = models.EmailField()
    email_cc = ArrayField(
        models.EmailField(),
        blank=True,
        default=list,
        help_text=&#34;list of comma separated email address in Cc&#34;,
    )
    email_bcc = ArrayField(
        models.EmailField(),
        blank=True,
        default=list,
        help_text=&#34;list of comma separated email address in Bcc&#34;,
    )
    email_subject = models.CharField(max_length=256)
    email_body = models.TextField()

    email_schedule = models.DateTimeField(
        blank=True, null=True, help_text=&#34;Schedule time to send email&#34;)
    email_repeat_after = models.DurationField(
        blank=True,
        null=True,
        help_text=
        &#34;Duration after which to resend email, You can remove it in future to stop the campaign and mark &#34;
        &#34;the task COMPLETE&#34;,
    )

    email_service = models.CharField(max_length=32,
                                     default=DEFAULT_EMAIL_SERVICE,
                                     choices=EMAIL_SERVICE_CHOICES)

    email_last_sent_at = models.DateTimeField(blank=True, null=True)
    task_status = models.CharField(
        default=TASK_STATUS_PENDING,
        choices=TASK_STATUS_CHOICES,
        max_length=128,
        help_text=&#34;Status of this email sending task&#34;,
    )
    email_send_count = models.IntegerField(
        default=0, help_text=&#34;Count of emails sent successfully&#34;)
    task_failed_count = models.IntegerField(
        default=0, help_text=&#34;Count of number of times this task failed&#34;)
    task_failure_info = ArrayField(
        models.JSONField(),
        null=True,
        blank=True,
        help_text=&#34;If task failed, information regarding why it failed&#34;,
    )

    @classmethod
    def pending_periodic_email_finder(cls):
        &#34;&#34;&#34;
        This method finds all the EmailScheduler objects which need to be sent in case of periodic task
        &#34;&#34;&#34;

        pending_emails = (cls.objects.select_for_update().exclude(
            email_repeat_after__exact=None,
            email_last_sent_at__exact=None).filter(
                task_status__exact=TASK_STATUS_PENDING,
                email_last_sent_at__lte=timezone.now() -
                F(&#34;email_repeat_after&#34;),
            ))
        return pending_emails

    def pre_update_processing(self):
        &#34;&#34;&#34;
        The purpose of this method is, to do preprocessing before updating an object.
        Currently, when we are updating an EmailScheduler object, and we are changing
        the email_repeat_after to None then we should automatically mark the task complete
        if it&#39;s not already in Failed state. Here we first fetch the object from db which contains the old state
        before updating and self contains the state after updating, hence db call is necessary.
        &#34;&#34;&#34;
        old_obj = EmailScheduler.objects.get(pk=self.pk)
        if (old_obj.email_repeat_after is not None
                and self.email_repeat_after is None
                and old_obj.task_status != TASK_STATUS_FAILED):
            self.task_status = TASK_STATUS_COMPLETE

    def save(self, *args, **kwargs):
        &#34;&#34;&#34;
        We have overrided the save method to call respective send email method i.e send immidiately or
        after specified duration. We also call pre_update_processing to update the obejct properly in case of
        update.
        Arguments:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.
        &#34;&#34;&#34;
        is_adding_new = self._state.adding
        if not is_adding_new:
            self.pre_update_processing()
        super(EmailScheduler, self).save(*args, **kwargs)
        if is_adding_new:
            if self.email_schedule is None:
                send_email.delay(self.pk)
            elif self.email_schedule is not None:
                td = self.email_schedule
                send_email.apply_async(
                    kwargs={&#34;email_scheduler_obj_id&#34;: self.pk}, eta=td)

    def update_fields(self, updated_fields: dict):
        &#34;&#34;&#34;
        This method takes the dict of the updated keys in the model. It updates the
        corresponding fields in the model instance and saves it in db.
        Arguments:
            updated_fields: dict of updated fields in the model
        &#34;&#34;&#34;
        update_fields = []
        for key, value in updated_fields.items():
            setattr(self, key, value)
            update_fields.append(key)
        self.save(update_fields=update_fields)


class EmailSchedulerLogs(models.Model):
    &#34;&#34;&#34;
    This class will define the EmailSchedulerLogs model
    &#34;&#34;&#34;
    email_scheduler = models.ForeignKey(EmailScheduler,
                                        on_delete=models.CASCADE)
    email_recipient_id = models.EmailField()
    email_message_id = models.TextField(null=True, blank=True)
    email_send_status = models.CharField(max_length=128, blank=True, null=True)
    email_recipient_type = models.CharField(
        max_length=8, choices=EMAIL_RECIPIENT_TYPE_CHOICES)
    retry_count = models.IntegerField(
        default=0, help_text=&#34;Number of times this email is being retried&#34;)
    email_event_info = models.JSONField(null=True, blank=True)

    @classmethod
    def create_logs(cls, logs_to_be_created: list):
        &#34;&#34;&#34;
        This method takes the list of logs to be created and creates them in bulk.
        Arguments:
            logs_to_be_created: list of logs to be created
        &#34;&#34;&#34;
        for log in logs_to_be_created:
            cls(**log).save()

    @classmethod
    def get_logs_to_be_updated(cls):
        &#34;&#34;&#34;
        This method returns the list of logs which are in pending state and are to be updated
        &#34;&#34;&#34;
        return (cls.objects.select_for_update().exclude(
            email_message_id__exact=None).filter(
                Q(email_send_status=None) | Q(email_send_status=&#34;sent&#34;)))

    def update_fields(self, updated_fields: dict):
        &#34;&#34;&#34;
        This method takes the dict of the updated keys in the model. It updates the
        corresponding fields in the model instance and saves it in db.
        Arguments:
            updated_fields: dict of updated fields in the model
        &#34;&#34;&#34;
        update_fields = []
        for key, value in updated_fields.items():
            setattr(self, key, value)
            update_fields.append(key)
        self.save(update_fields=update_fields)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="apps.email_scheduler.models.EmailScheduler"><code class="flex name class">
<span>class <span class="ident">EmailScheduler</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This class will define the EmailScheduler model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmailScheduler(models.Model):
    &#34;&#34;&#34;
    This class will define the EmailScheduler model
    &#34;&#34;&#34;
    email_to = models.EmailField()
    email_cc = ArrayField(
        models.EmailField(),
        blank=True,
        default=list,
        help_text=&#34;list of comma separated email address in Cc&#34;,
    )
    email_bcc = ArrayField(
        models.EmailField(),
        blank=True,
        default=list,
        help_text=&#34;list of comma separated email address in Bcc&#34;,
    )
    email_subject = models.CharField(max_length=256)
    email_body = models.TextField()

    email_schedule = models.DateTimeField(
        blank=True, null=True, help_text=&#34;Schedule time to send email&#34;)
    email_repeat_after = models.DurationField(
        blank=True,
        null=True,
        help_text=
        &#34;Duration after which to resend email, You can remove it in future to stop the campaign and mark &#34;
        &#34;the task COMPLETE&#34;,
    )

    email_service = models.CharField(max_length=32,
                                     default=DEFAULT_EMAIL_SERVICE,
                                     choices=EMAIL_SERVICE_CHOICES)

    email_last_sent_at = models.DateTimeField(blank=True, null=True)
    task_status = models.CharField(
        default=TASK_STATUS_PENDING,
        choices=TASK_STATUS_CHOICES,
        max_length=128,
        help_text=&#34;Status of this email sending task&#34;,
    )
    email_send_count = models.IntegerField(
        default=0, help_text=&#34;Count of emails sent successfully&#34;)
    task_failed_count = models.IntegerField(
        default=0, help_text=&#34;Count of number of times this task failed&#34;)
    task_failure_info = ArrayField(
        models.JSONField(),
        null=True,
        blank=True,
        help_text=&#34;If task failed, information regarding why it failed&#34;,
    )

    @classmethod
    def pending_periodic_email_finder(cls):
        &#34;&#34;&#34;
        This method finds all the EmailScheduler objects which need to be sent in case of periodic task
        &#34;&#34;&#34;

        pending_emails = (cls.objects.select_for_update().exclude(
            email_repeat_after__exact=None,
            email_last_sent_at__exact=None).filter(
                task_status__exact=TASK_STATUS_PENDING,
                email_last_sent_at__lte=timezone.now() -
                F(&#34;email_repeat_after&#34;),
            ))
        return pending_emails

    def pre_update_processing(self):
        &#34;&#34;&#34;
        The purpose of this method is, to do preprocessing before updating an object.
        Currently, when we are updating an EmailScheduler object, and we are changing
        the email_repeat_after to None then we should automatically mark the task complete
        if it&#39;s not already in Failed state. Here we first fetch the object from db which contains the old state
        before updating and self contains the state after updating, hence db call is necessary.
        &#34;&#34;&#34;
        old_obj = EmailScheduler.objects.get(pk=self.pk)
        if (old_obj.email_repeat_after is not None
                and self.email_repeat_after is None
                and old_obj.task_status != TASK_STATUS_FAILED):
            self.task_status = TASK_STATUS_COMPLETE

    def save(self, *args, **kwargs):
        &#34;&#34;&#34;
        We have overrided the save method to call respective send email method i.e send immidiately or
        after specified duration. We also call pre_update_processing to update the obejct properly in case of
        update.
        Arguments:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.
        &#34;&#34;&#34;
        is_adding_new = self._state.adding
        if not is_adding_new:
            self.pre_update_processing()
        super(EmailScheduler, self).save(*args, **kwargs)
        if is_adding_new:
            if self.email_schedule is None:
                send_email.delay(self.pk)
            elif self.email_schedule is not None:
                td = self.email_schedule
                send_email.apply_async(
                    kwargs={&#34;email_scheduler_obj_id&#34;: self.pk}, eta=td)

    def update_fields(self, updated_fields: dict):
        &#34;&#34;&#34;
        This method takes the dict of the updated keys in the model. It updates the
        corresponding fields in the model instance and saves it in db.
        Arguments:
            updated_fields: dict of updated fields in the model
        &#34;&#34;&#34;
        update_fields = []
        for key, value in updated_fields.items():
            setattr(self, key, value)
            update_fields.append(key)
        self.save(update_fields=update_fields)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>django.db.models.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="apps.email_scheduler.models.EmailScheduler.DoesNotExist"><code class="name">var <span class="ident">DoesNotExist</span></code></dt>
<dd>
<div class="desc"><p>The requested object does not exist</p></div>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.MultipleObjectsReturned"><code class="name">var <span class="ident">MultipleObjectsReturned</span></code></dt>
<dd>
<div class="desc"><p>The query returned multiple objects when only one was expected.</p></div>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.objects"><code class="name">var <span class="ident">objects</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="apps.email_scheduler.models.EmailScheduler.pending_periodic_email_finder"><code class="name flex">
<span>def <span class="ident">pending_periodic_email_finder</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>This method finds all the EmailScheduler objects which need to be sent in case of periodic task</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def pending_periodic_email_finder(cls):
    &#34;&#34;&#34;
    This method finds all the EmailScheduler objects which need to be sent in case of periodic task
    &#34;&#34;&#34;

    pending_emails = (cls.objects.select_for_update().exclude(
        email_repeat_after__exact=None,
        email_last_sent_at__exact=None).filter(
            task_status__exact=TASK_STATUS_PENDING,
            email_last_sent_at__lte=timezone.now() -
            F(&#34;email_repeat_after&#34;),
        ))
    return pending_emails</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="apps.email_scheduler.models.EmailScheduler.email_bcc"><code class="name">var <span class="ident">email_bcc</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.email_body"><code class="name">var <span class="ident">email_body</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.email_cc"><code class="name">var <span class="ident">email_cc</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.email_last_sent_at"><code class="name">var <span class="ident">email_last_sent_at</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.email_repeat_after"><code class="name">var <span class="ident">email_repeat_after</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.email_schedule"><code class="name">var <span class="ident">email_schedule</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.email_send_count"><code class="name">var <span class="ident">email_send_count</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.email_service"><code class="name">var <span class="ident">email_service</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.email_subject"><code class="name">var <span class="ident">email_subject</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.email_to"><code class="name">var <span class="ident">email_to</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.emailschedulerlogs_set"><code class="name">var <span class="ident">emailschedulerlogs_set</span></code></dt>
<dd>
<div class="desc"><p>Accessor to the related objects manager on the reverse side of a
many-to-one relation.</p>
<p>In the example::</p>
<pre><code>class Child(Model):
    parent = ForeignKey(Parent, related_name='children')
</code></pre>
<p><code>Parent.children</code> is a <code>ReverseManyToOneDescriptor</code> instance.</p>
<p>Most of the implementation is delegated to a dynamically defined manager
class built by <code>create_forward_many_to_many_manager()</code> defined below.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Get the related objects through the reverse relation.

    With the example above, when getting ``parent.children``:

    - ``self`` is the descriptor managing the ``children`` attribute
    - ``instance`` is the ``parent`` instance
    - ``cls`` is the ``Parent`` class (unused)
    &#34;&#34;&#34;
    if instance is None:
        return self

    return self.related_manager_cls(instance)</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.task_failed_count"><code class="name">var <span class="ident">task_failed_count</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.task_failure_info"><code class="name">var <span class="ident">task_failure_info</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.task_status"><code class="name">var <span class="ident">task_status</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="apps.email_scheduler.models.EmailScheduler.get_email_service_display"><code class="name flex">
<span>def <span class="ident">get_email_service_display</span></span>(<span>self, *, field=&lt;django.db.models.fields.CharField: email_service&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _method(cls_or_self, /, *args, **keywords):
    keywords = {**self.keywords, **keywords}
    return self.func(cls_or_self, *self.args, *args, **keywords)</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.get_task_status_display"><code class="name flex">
<span>def <span class="ident">get_task_status_display</span></span>(<span>self, *, field=&lt;django.db.models.fields.CharField: task_status&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _method(cls_or_self, /, *args, **keywords):
    keywords = {**self.keywords, **keywords}
    return self.func(cls_or_self, *self.args, *args, **keywords)</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.pre_update_processing"><code class="name flex">
<span>def <span class="ident">pre_update_processing</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The purpose of this method is, to do preprocessing before updating an object.
Currently, when we are updating an EmailScheduler object, and we are changing
the email_repeat_after to None then we should automatically mark the task complete
if it's not already in Failed state. Here we first fetch the object from db which contains the old state
before updating and self contains the state after updating, hence db call is necessary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pre_update_processing(self):
    &#34;&#34;&#34;
    The purpose of this method is, to do preprocessing before updating an object.
    Currently, when we are updating an EmailScheduler object, and we are changing
    the email_repeat_after to None then we should automatically mark the task complete
    if it&#39;s not already in Failed state. Here we first fetch the object from db which contains the old state
    before updating and self contains the state after updating, hence db call is necessary.
    &#34;&#34;&#34;
    old_obj = EmailScheduler.objects.get(pk=self.pk)
    if (old_obj.email_repeat_after is not None
            and self.email_repeat_after is None
            and old_obj.task_status != TASK_STATUS_FAILED):
        self.task_status = TASK_STATUS_COMPLETE</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>We have overrided the save method to call respective send email method i.e send immidiately or
after specified duration. We also call pre_update_processing to update the obejct properly in case of
update.</p>
<h2 id="arguments">Arguments</h2>
<p><em>args: Variable length argument list.
</em>*kwargs: Arbitrary keyword arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, *args, **kwargs):
    &#34;&#34;&#34;
    We have overrided the save method to call respective send email method i.e send immidiately or
    after specified duration. We also call pre_update_processing to update the obejct properly in case of
    update.
    Arguments:
        *args: Variable length argument list.
        **kwargs: Arbitrary keyword arguments.
    &#34;&#34;&#34;
    is_adding_new = self._state.adding
    if not is_adding_new:
        self.pre_update_processing()
    super(EmailScheduler, self).save(*args, **kwargs)
    if is_adding_new:
        if self.email_schedule is None:
            send_email.delay(self.pk)
        elif self.email_schedule is not None:
            td = self.email_schedule
            send_email.apply_async(
                kwargs={&#34;email_scheduler_obj_id&#34;: self.pk}, eta=td)</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailScheduler.update_fields"><code class="name flex">
<span>def <span class="ident">update_fields</span></span>(<span>self, updated_fields: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>This method takes the dict of the updated keys in the model. It updates the
corresponding fields in the model instance and saves it in db.</p>
<h2 id="arguments">Arguments</h2>
<p>updated_fields: dict of updated fields in the model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_fields(self, updated_fields: dict):
    &#34;&#34;&#34;
    This method takes the dict of the updated keys in the model. It updates the
    corresponding fields in the model instance and saves it in db.
    Arguments:
        updated_fields: dict of updated fields in the model
    &#34;&#34;&#34;
    update_fields = []
    for key, value in updated_fields.items():
        setattr(self, key, value)
        update_fields.append(key)
    self.save(update_fields=update_fields)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs"><code class="flex name class">
<span>class <span class="ident">EmailSchedulerLogs</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This class will define the EmailSchedulerLogs model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmailSchedulerLogs(models.Model):
    &#34;&#34;&#34;
    This class will define the EmailSchedulerLogs model
    &#34;&#34;&#34;
    email_scheduler = models.ForeignKey(EmailScheduler,
                                        on_delete=models.CASCADE)
    email_recipient_id = models.EmailField()
    email_message_id = models.TextField(null=True, blank=True)
    email_send_status = models.CharField(max_length=128, blank=True, null=True)
    email_recipient_type = models.CharField(
        max_length=8, choices=EMAIL_RECIPIENT_TYPE_CHOICES)
    retry_count = models.IntegerField(
        default=0, help_text=&#34;Number of times this email is being retried&#34;)
    email_event_info = models.JSONField(null=True, blank=True)

    @classmethod
    def create_logs(cls, logs_to_be_created: list):
        &#34;&#34;&#34;
        This method takes the list of logs to be created and creates them in bulk.
        Arguments:
            logs_to_be_created: list of logs to be created
        &#34;&#34;&#34;
        for log in logs_to_be_created:
            cls(**log).save()

    @classmethod
    def get_logs_to_be_updated(cls):
        &#34;&#34;&#34;
        This method returns the list of logs which are in pending state and are to be updated
        &#34;&#34;&#34;
        return (cls.objects.select_for_update().exclude(
            email_message_id__exact=None).filter(
                Q(email_send_status=None) | Q(email_send_status=&#34;sent&#34;)))

    def update_fields(self, updated_fields: dict):
        &#34;&#34;&#34;
        This method takes the dict of the updated keys in the model. It updates the
        corresponding fields in the model instance and saves it in db.
        Arguments:
            updated_fields: dict of updated fields in the model
        &#34;&#34;&#34;
        update_fields = []
        for key, value in updated_fields.items():
            setattr(self, key, value)
            update_fields.append(key)
        self.save(update_fields=update_fields)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>django.db.models.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs.DoesNotExist"><code class="name">var <span class="ident">DoesNotExist</span></code></dt>
<dd>
<div class="desc"><p>The requested object does not exist</p></div>
</dd>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs.MultipleObjectsReturned"><code class="name">var <span class="ident">MultipleObjectsReturned</span></code></dt>
<dd>
<div class="desc"><p>The query returned multiple objects when only one was expected.</p></div>
</dd>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs.objects"><code class="name">var <span class="ident">objects</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs.create_logs"><code class="name flex">
<span>def <span class="ident">create_logs</span></span>(<span>logs_to_be_created: list)</span>
</code></dt>
<dd>
<div class="desc"><p>This method takes the list of logs to be created and creates them in bulk.</p>
<h2 id="arguments">Arguments</h2>
<p>logs_to_be_created: list of logs to be created</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_logs(cls, logs_to_be_created: list):
    &#34;&#34;&#34;
    This method takes the list of logs to be created and creates them in bulk.
    Arguments:
        logs_to_be_created: list of logs to be created
    &#34;&#34;&#34;
    for log in logs_to_be_created:
        cls(**log).save()</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs.get_logs_to_be_updated"><code class="name flex">
<span>def <span class="ident">get_logs_to_be_updated</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns the list of logs which are in pending state and are to be updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_logs_to_be_updated(cls):
    &#34;&#34;&#34;
    This method returns the list of logs which are in pending state and are to be updated
    &#34;&#34;&#34;
    return (cls.objects.select_for_update().exclude(
        email_message_id__exact=None).filter(
            Q(email_send_status=None) | Q(email_send_status=&#34;sent&#34;)))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs.email_event_info"><code class="name">var <span class="ident">email_event_info</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs.email_message_id"><code class="name">var <span class="ident">email_message_id</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs.email_recipient_id"><code class="name">var <span class="ident">email_recipient_id</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs.email_recipient_type"><code class="name">var <span class="ident">email_recipient_type</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs.email_scheduler"><code class="name">var <span class="ident">email_scheduler</span></code></dt>
<dd>
<div class="desc"><p>Accessor to the related object on the forward side of a many-to-one or
one-to-one (via ForwardOneToOneDescriptor subclass) relation.</p>
<p>In the example::</p>
<pre><code>class Child(Model):
    parent = ForeignKey(Parent, related_name='children')
</code></pre>
<p><code>Child.parent</code> is a <code>ForwardManyToOneDescriptor</code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Get the related instance through the forward relation.

    With the example above, when getting ``child.parent``:

    - ``self`` is the descriptor managing the ``parent`` attribute
    - ``instance`` is the ``child`` instance
    - ``cls`` is the ``Child`` class (we don&#39;t need it)
    &#34;&#34;&#34;
    if instance is None:
        return self

    # The related instance is loaded from the database and then cached
    # by the field on the model instance state. It can also be pre-cached
    # by the reverse accessor (ReverseOneToOneDescriptor).
    try:
        rel_obj = self.field.get_cached_value(instance)
    except KeyError:
        has_value = None not in self.field.get_local_related_value(instance)
        ancestor_link = instance._meta.get_ancestor_link(self.field.model) if has_value else None
        if ancestor_link and ancestor_link.is_cached(instance):
            # An ancestor link will exist if this field is defined on a
            # multi-table inheritance parent of the instance&#39;s class.
            ancestor = ancestor_link.get_cached_value(instance)
            # The value might be cached on an ancestor if the instance
            # originated from walking down the inheritance chain.
            rel_obj = self.field.get_cached_value(ancestor, default=None)
        else:
            rel_obj = None
        if rel_obj is None and has_value:
            rel_obj = self.get_object(instance)
            remote_field = self.field.remote_field
            # If this is a one-to-one relation, set the reverse accessor
            # cache on the related object to the current instance to avoid
            # an extra SQL query if it&#39;s accessed later on.
            if not remote_field.multiple:
                remote_field.set_cached_value(rel_obj, instance)
        self.field.set_cached_value(instance, rel_obj)

    if rel_obj is None and not self.field.null:
        raise self.RelatedObjectDoesNotExist(
            &#34;%s has no %s.&#34; % (self.field.model.__name__, self.field.name)
        )
    else:
        return rel_obj</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs.email_scheduler_id"><code class="name">var <span class="ident">email_scheduler_id</span></code></dt>
<dd>
<div class="desc"><p>Retrieve and caches the value from the datastore on the first lookup.
Return the cached value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs.email_send_status"><code class="name">var <span class="ident">email_send_status</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs.retry_count"><code class="name">var <span class="ident">retry_count</span></code></dt>
<dd>
<div class="desc"><p>A wrapper for a deferred-loading field. When the value is read from this
object the first time, the query is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, cls=None):
    &#34;&#34;&#34;
    Retrieve and caches the value from the datastore on the first lookup.
    Return the cached value.
    &#34;&#34;&#34;
    if instance is None:
        return self
    data = instance.__dict__
    field_name = self.field.attname
    if field_name not in data:
        # Let&#39;s see if the field is part of the parent chain. If so we
        # might be able to reuse the already loaded value. Refs #18343.
        val = self._check_parent_chain(instance)
        if val is None:
            instance.refresh_from_db(fields=[field_name])
            val = getattr(instance, field_name)
        data[field_name] = val
    return data[field_name]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs.get_email_recipient_type_display"><code class="name flex">
<span>def <span class="ident">get_email_recipient_type_display</span></span>(<span>self, *, field=&lt;django.db.models.fields.CharField: email_recipient_type&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _method(cls_or_self, /, *args, **keywords):
    keywords = {**self.keywords, **keywords}
    return self.func(cls_or_self, *self.args, *args, **keywords)</code></pre>
</details>
</dd>
<dt id="apps.email_scheduler.models.EmailSchedulerLogs.update_fields"><code class="name flex">
<span>def <span class="ident">update_fields</span></span>(<span>self, updated_fields: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>This method takes the dict of the updated keys in the model. It updates the
corresponding fields in the model instance and saves it in db.</p>
<h2 id="arguments">Arguments</h2>
<p>updated_fields: dict of updated fields in the model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_fields(self, updated_fields: dict):
    &#34;&#34;&#34;
    This method takes the dict of the updated keys in the model. It updates the
    corresponding fields in the model instance and saves it in db.
    Arguments:
        updated_fields: dict of updated fields in the model
    &#34;&#34;&#34;
    update_fields = []
    for key, value in updated_fields.items():
        setattr(self, key, value)
        update_fields.append(key)
    self.save(update_fields=update_fields)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="apps.email_scheduler" href="index.html">apps.email_scheduler</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="apps.email_scheduler.models.EmailScheduler" href="#apps.email_scheduler.models.EmailScheduler">EmailScheduler</a></code></h4>
<ul class="">
<li><code><a title="apps.email_scheduler.models.EmailScheduler.DoesNotExist" href="#apps.email_scheduler.models.EmailScheduler.DoesNotExist">DoesNotExist</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.MultipleObjectsReturned" href="#apps.email_scheduler.models.EmailScheduler.MultipleObjectsReturned">MultipleObjectsReturned</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.email_bcc" href="#apps.email_scheduler.models.EmailScheduler.email_bcc">email_bcc</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.email_body" href="#apps.email_scheduler.models.EmailScheduler.email_body">email_body</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.email_cc" href="#apps.email_scheduler.models.EmailScheduler.email_cc">email_cc</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.email_last_sent_at" href="#apps.email_scheduler.models.EmailScheduler.email_last_sent_at">email_last_sent_at</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.email_repeat_after" href="#apps.email_scheduler.models.EmailScheduler.email_repeat_after">email_repeat_after</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.email_schedule" href="#apps.email_scheduler.models.EmailScheduler.email_schedule">email_schedule</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.email_send_count" href="#apps.email_scheduler.models.EmailScheduler.email_send_count">email_send_count</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.email_service" href="#apps.email_scheduler.models.EmailScheduler.email_service">email_service</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.email_subject" href="#apps.email_scheduler.models.EmailScheduler.email_subject">email_subject</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.email_to" href="#apps.email_scheduler.models.EmailScheduler.email_to">email_to</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.emailschedulerlogs_set" href="#apps.email_scheduler.models.EmailScheduler.emailschedulerlogs_set">emailschedulerlogs_set</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.get_email_service_display" href="#apps.email_scheduler.models.EmailScheduler.get_email_service_display">get_email_service_display</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.get_task_status_display" href="#apps.email_scheduler.models.EmailScheduler.get_task_status_display">get_task_status_display</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.id" href="#apps.email_scheduler.models.EmailScheduler.id">id</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.objects" href="#apps.email_scheduler.models.EmailScheduler.objects">objects</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.pending_periodic_email_finder" href="#apps.email_scheduler.models.EmailScheduler.pending_periodic_email_finder">pending_periodic_email_finder</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.pre_update_processing" href="#apps.email_scheduler.models.EmailScheduler.pre_update_processing">pre_update_processing</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.save" href="#apps.email_scheduler.models.EmailScheduler.save">save</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.task_failed_count" href="#apps.email_scheduler.models.EmailScheduler.task_failed_count">task_failed_count</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.task_failure_info" href="#apps.email_scheduler.models.EmailScheduler.task_failure_info">task_failure_info</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.task_status" href="#apps.email_scheduler.models.EmailScheduler.task_status">task_status</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailScheduler.update_fields" href="#apps.email_scheduler.models.EmailScheduler.update_fields">update_fields</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="apps.email_scheduler.models.EmailSchedulerLogs" href="#apps.email_scheduler.models.EmailSchedulerLogs">EmailSchedulerLogs</a></code></h4>
<ul class="">
<li><code><a title="apps.email_scheduler.models.EmailSchedulerLogs.DoesNotExist" href="#apps.email_scheduler.models.EmailSchedulerLogs.DoesNotExist">DoesNotExist</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailSchedulerLogs.MultipleObjectsReturned" href="#apps.email_scheduler.models.EmailSchedulerLogs.MultipleObjectsReturned">MultipleObjectsReturned</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailSchedulerLogs.create_logs" href="#apps.email_scheduler.models.EmailSchedulerLogs.create_logs">create_logs</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailSchedulerLogs.email_event_info" href="#apps.email_scheduler.models.EmailSchedulerLogs.email_event_info">email_event_info</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailSchedulerLogs.email_message_id" href="#apps.email_scheduler.models.EmailSchedulerLogs.email_message_id">email_message_id</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailSchedulerLogs.email_recipient_id" href="#apps.email_scheduler.models.EmailSchedulerLogs.email_recipient_id">email_recipient_id</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailSchedulerLogs.email_recipient_type" href="#apps.email_scheduler.models.EmailSchedulerLogs.email_recipient_type">email_recipient_type</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailSchedulerLogs.email_scheduler" href="#apps.email_scheduler.models.EmailSchedulerLogs.email_scheduler">email_scheduler</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailSchedulerLogs.email_scheduler_id" href="#apps.email_scheduler.models.EmailSchedulerLogs.email_scheduler_id">email_scheduler_id</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailSchedulerLogs.email_send_status" href="#apps.email_scheduler.models.EmailSchedulerLogs.email_send_status">email_send_status</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailSchedulerLogs.get_email_recipient_type_display" href="#apps.email_scheduler.models.EmailSchedulerLogs.get_email_recipient_type_display">get_email_recipient_type_display</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailSchedulerLogs.get_logs_to_be_updated" href="#apps.email_scheduler.models.EmailSchedulerLogs.get_logs_to_be_updated">get_logs_to_be_updated</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailSchedulerLogs.id" href="#apps.email_scheduler.models.EmailSchedulerLogs.id">id</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailSchedulerLogs.objects" href="#apps.email_scheduler.models.EmailSchedulerLogs.objects">objects</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailSchedulerLogs.retry_count" href="#apps.email_scheduler.models.EmailSchedulerLogs.retry_count">retry_count</a></code></li>
<li><code><a title="apps.email_scheduler.models.EmailSchedulerLogs.update_fields" href="#apps.email_scheduler.models.EmailSchedulerLogs.update_fields">update_fields</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>